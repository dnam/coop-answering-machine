package org.nii.cqa.parser;

import org.nii.cqa.base.*;
import java.util.*;
import java.io.*;

parser code {:

	private CoopQAJob job;
	
	public KBParser (java.io.Reader input, job) {
		super(new KBScanner(input));
		this.job = job;
	}
	
	public CoopQAJob getJob() {
		return job;
	}
	
	/* Test code */
	public static void main(String args[]) throws Exception {
		KBParser p;
		p = new KBParser(new FileReader("../CQA/lib/test.txt"));
		
		KnowledgeBase q = (KnowledgeBase) p.parse().value;
		System.out.println("Result: " + q);
	}
	
:}

terminal COMMA, AND, NEG, LPAREN, RPAREN, OR, IMPLY;
terminal String NONVAR, VARIABLE;

non terminal Vector<Integer> tuple, closedTuple;
non terminal Literal basic_literal, literal;
non terminal Clause clause;
non terminal Vector<Literal> ruleSide;
non terminal Rule rule;
non terminal KnowledgeBase kb;

precedence left AND, OR;
precedence left NEG;
precedence left IMPLY;

kb ::= literal:l
			{: Clause c = new Clause(); c.add(l); 
				KnowledgeBase k = new KnowledgeBase();
				k.add(c); RESULT=k; 
			:}
		| clause:c
			{:	KnowledgeBase k = new KnowledgeBase(parser.getJob());
				k.add(c); RESULT=k;
			:}
		| rule:r
			{:	KnowledgeBase k = new KnowledgeBase(parser.getJob());
				k.add(r); RESULT=k;
			:}
		| kb:k COMMA literal:l
			{:	 Clause c = new Clause(); c.add(l); k.add(c); RESULT=k; :}
		| kb:k COMMA clause:c
			{:	k.add(c); RESULT=k; :}
		| kb:k COMMA rule:r
			{:	k.add(r); RESULT=k; :}
		;
		
clause ::= literal:l1 OR literal:l2
			{: Clause c = new Clause(); c.add(l1); c.add(l2); RESULT=c; :}
		| clause:c OR literal: l
			{: c.add(l); RESULT=c; :}
		;
		
rule ::= ruleSide:l IMPLY ruleSide:r
			{: Rule rule = new Rule(l, r); RESULT=rule; :}
		| literal:l IMPLY literal:r
			{: Rule rule = new Rule(); rule.addRight(r); rule.addLeft(l); RESULT=rule; :}
		| literal:l IMPLY ruleSide:r
			{: Rule rule = new Rule(null, r); rule.addLeft(l); RESULT=rule; :}
		| ruleSide:l IMPLY literal:r
			{: Rule rule = new Rule(l, null); rule.addRight(r); RESULT=rule; :}
		;
		
ruleSide ::= literal:l1 AND literal:l2
			{: Vector<Literal> s = new Vector<Literal>(); s.add(l1); s.add(l2); RESULT=s; :}
		| ruleSide:s AND literal:l
			{: s.add(l); RESULT=s; :}
		;	
		
literal ::= basic_literal:l
			{: RESULT=l; :}
		| NEG basic_literal:negLit
			{: negLit.setNegative(true); RESULT=negLit; :}
		;
		
basic_literal ::= NONVAR:pred closedTuple:t
			{: Literal l = new Literal(parser.getJob()); l.setID(parser.getJob().symTab().addSymbol(pred, SymType.PREDICATE)); l.setNegative(false); l.setMultiParams(t); RESULT=l; :}
		;

closedTuple ::= LPAREN tuple:t RPAREN
				{: RESULT=t; :}
			;

tuple ::= NONVAR:str 
			{: Vector<Integer> tup = new Vector<Integer>(); tup.add(parser.getJob().symTab().addSymbol(str, SymType.CONSTANT)); RESULT=tup; :}
		| VARIABLE:str 
			{: Vector<Integer> tup = new Vector<Integer>(); tup.add(parser.getJob().symTab().addSymbol(str, SymType.VARIABLE)); RESULT=tup; :}
		| tuple:t COMMA NONVAR:str 
			{: t.add(parser.getJob().symTab().addSymbol(str, SymType.CONSTANT));RESULT=t; :}
		| tuple:t COMMA VARIABLE:str 
			{: t.add(parser.getJob().symTab().addSymbol(str, SymType.VARIABLE));RESULT=t; :}
		;	