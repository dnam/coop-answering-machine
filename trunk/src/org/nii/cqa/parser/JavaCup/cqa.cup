package org.nii.cqa.parser;

import java_cup.runtime.*;

parser code {:
	public static void main(String args[]) throws Exception {
		SymbolFactory sf = new DefaultSymbolFactory();
		if (args.length==0) new Parser(new Scanner(System.in,sf),sf).parse();
		else new Parser(new Scanner(new java.io.FileInputStream(args[0]),sf),sf).parse();
	}
:}

terminal COMMA, AND, NEG, LPAREN, RPAREN;
terminal String NONVAR, VARIABLE;

non terminal Vector<Integer> tuple, closedTuple;
non terminal Literal basic_literal, literal;
non terminal Query query;

precedence left COMMA;
precedence left AND;
precedence left NEG;

query ::= literal:l 
			{: Query q = new Query(); q.add(l); RESULT=q; :}
		| query:q AND literal:l
			{: q.add(l); RESULT=q; :}
		;
		
literal ::= basic_literal:l
			{: RESULT=l; :}
		| NEG basic_literal:negLit
			{: negLit.setNegative(true); RESULT=negLit; :}
		;
		
basic_literal ::= NONVAR:pred closedTuple:t
			{: Literal l = new Literal(); l.setID(SymTable.addSymbol(pred)); l.setNegative(false); l.setParam(t); RESULT=l:}
		;

closedTuple ::= LPAREN tuple:t RPAREN
				{: RESULT=t; :}
			;

tuple ::= NONVAR:str 
			{: Vector<Integer> tup = new Vector<Integer>(); tup.add(SymTable.addSymbol(str)); RESULT=tup; :}
		| VARIABLE:str 
			{: Vector<Integer> tup = new Vector<Integer>(); tup.add(SymTable.addSymbol(str)); RESULT=tup; :}
		| tuple:t COMMA NONVAR:str 
			{: t.add(SymTable.addSymbol(str));RESULT=l; :}
		| tuple:t COMMA VARIABLE:str 
			{: t.add(SymTable.addSymbol(str));RESULT=l; :}
		;	